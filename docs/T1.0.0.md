<br/>


!> <span style='color:RED'>[ 在`TS`中，类型注解需使用小写 ] [ 因内置构造函数`Number | String | Boolean`它们用于`JS`中创建包装对象 ]</span>

```csharp
# [ 基础注解 ]
const v: string = "Hello World";
const v: number = 10.25;
const v: boolean = true;

# [ 集合注解 ]
const vs: string[] = ["Hello", "World"];
const vs: Array<string> = ["Hello", "World"];

# [ 其他注解 ]
const x: any = "Hello World";


```

```csharp
# [ 联合注解 ] 
const v: (number | string) = 10;
const v: ('男' | '女') = '女'; 

type T1 = string | number | '男' | '女';
const x: T1 = 10;

-----------------------------------
    
# [ 对象注解 ] 
# [ A.1 ] 确定对象结构 ( 在 TS 中, 推荐使用接口来限制对象结构：import { type IAddress } from )
type Address = {
    num: number
    city: string
    zip: (string | number)
}

const o: Address = {
    num: 10,
    city: "北京",
    zip: "100000"
}
  
# [ A.2 ] 确定对象结构 ( 简化方式 )
const o: { p1:string, p2: number } = {
              p1: "张三",
              p2: 30
         }
    
# [ B.1 ] 不确定对象结构
const o: Record<string, any>  
const o: Record<string, string | number> 

    
```

!> <span style='color:red'>[ 函数注解`type M = (a: number, b: number) => void`：此方式定义，其中`void`不会严格限制返回类型 ]</span>

```csharp
# [ A ][ 函数注解 ]
let M1: (a: number, b: number) => void;
M1 = function(a: number, b: number): void {
    console.log(a + b);
}

M1 = (a, b) => {
    console.log(a + b);
}

---------------------------------------------

const M1 = async function(a: number, b: number): Promise<void> {
    console.log(a + b);
}

const M1: (a: number, b: number) => Promise<void> = async (a, b) => {
    console.log(a + b);
}


```

