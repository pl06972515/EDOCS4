<br/>

!> <span style='color:RED'>[ 在`TS`中，类型注解需使用小写 ] [ 因内置构造函数`Number | String | Boolean`它们用于`JS`中创建包装对象 ]</span>

<!-- tabs:start -->

#### **[ 基本注解 ]**



```csharp
# [ 基础注解 ]
const v: string = "Hello World";
const v: number = 10.25;
const v: boolean = true;

# [ 其他注解 ]
const x: any = "Hello World";


```

```csharp
# [ 集合注解 ]
const vs: Array<string> = ["Hello", "World"];

# [ 对象注解 ] 
# [ A.1 ] 确定对象结构 ( 在 TS 中, 推荐使用接口来限制对象结构：import { type IAddress } from )
type Address = {
    num: number
    city: string
    zip: (string | number)
}

const o: Address = {
    num: 10,
    city: "北京",
    zip: "100000"
}
  
# [ A.2 ] 确定对象结构 ( 简化方式 )
const o: { p1:string, p2: number } = {
              p1: "张三",
              p2: 30
         }
    
# [ B.1 ] 不确定对象结构
const o: Record<string, any>  
const o: Record<string, string | number> 

    
```

```csharp
# [ 联合注解 ] 
const v: (number | string) = 10;
const v: ('男' | '女') = '女'; 

type T1 = string | number | '男' | '女';
const x: T1 = 10;


```



#### **[ ℹ️ 函数注解 ]**

!> <span style='color:red'>[ 函数注解`type M = (a: number, b: number) => void`：此方式定义，其中`void`不会严格限制返回类型 ]</span>

```csharp
# [ 同步函数 ]
// const M1 = (a, b) => { }
const M1 = (a: number, b: number) => void {

}

const M1 = (callback: (a: number, b: number) => void) => {

}


```

```csharp
# [ 异步函数 ]
// const M1 = async (a, b) => { }
const M1 = async function (a: number, b: number): Promise<void> {
   
}
    
const M1 = (callback: (a: number, b: number) => Promise<void>) => {

}


```



<!-- tabs:end -->

