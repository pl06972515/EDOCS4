<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 在`JS`中内置构造函数`Number | String | Boolean`它们用于创建其 <span style='color:Blue'>[ 包装对象 ]</span>
>
>   <span style='color:RED'>[ 因此：在`TS`中，也是同理，类型注解需使用小写 -`x: String`是包装对象 ]</span>
>
>
><br/>

```csharp
# [ 基础注解 ]
const v: string = "Hello World";
const v: number = 10.25;
const v: boolean = true;

# [ 集合注解 ]
const vs: string[] = ["Hello", "World"];
const vs: Array<string> = ["Hello", "World"];
const vs: Iterable<string> = ["Hello", "World"];

# [ 其他注解 ]
const x: any = "Hello World";


```

```csharp
# [ 联合注解 ]  
type T1 = string | number;
const x: T1 = 10;
const y: number | string = 10;

-----------------------------------
    
type T1 = '男' | '女';
const x: T1 = '男';
const y: ('男' | '女') = '女';

-----------------------------------
    
# [ 对象注解 ] 限制对象结构 ( 在 TS 中, 推荐使用接口来限制对象结构 )
type Address = {
    num: number
    city: string
    zip: string
}

const v: Address = {
    num: 10,
    city: "北京",
    zip: "100000"
}
  

```

!> <span style='color:red'>[ 函数注解`type M = (a: number, b: number) => void`：此方式定义，其中`void`不会严格限制返回类型 ]</span>

```csharp
# [ A ][ 函数注解 ]
let M1: (a: number, b: number) => void;
M1 = function(a: number, b: number): void {
    console.log(a + b);
}

M1 = (a, b) => {
    console.log(a + b);
}

---------------------------------------------

let M1: (a: number, b: number) => number;
M1 = function(a: number, b: number): number {
    return a + b;
}

M1 = (a, b) => { 
    return a + b;
}

---------------------------------------------

const M1 = async function(a: number, b: number): Promise<void> {
    console.log(a + b);
}

const M1: (a: number, b: number) => Promise<void> = async (a, b) => {
    console.log(a + b);
}


```

