<br/>

!> <span style='color:Blue'>(`EXT`) 针对函数提供了大量的 [ 函数包装器 ]</span>

<!-- tabs:start -->

#### **[ 防抖函数 ]**

```csharp
/// <summary>
/// Ext.Function.createBuffered(fn, buffer, [scope], [args]) : Function
/// - fn: 函数对象
/// - buffer: 防抖阈值 ( 毫秒 )
/// - scope:  函数内部 ( this: 作用域 )
/// - args:   函数参数
///
/// </summary>

const proxyfn = Ext.Function.createBuffered(function () {
    console.log('执行防抖函数');
}, 300);

proxyfn();
proxyfn();
proxyfn();


```



#### **[ 节流函数 ]**

```csharp
/// <summary>
/// Ext.Function.createThrottled(fn, buffer, [scope]) : Function
/// - fn: 函数对象
/// - buffer: 节流阈值 ( 毫秒 )
/// - scope:  函数内部 ( this: 作用域 )
///
/// </summary>

# [ 此函数可能有问题: 会重复执行 2 次 ]
const throttledFunction = Ext.Function.createThrottled(function () {
    console.log('节流函数执行 - 时间:', new Date().toLocaleTimeString());
}, 3000);

console.log('开始调用');
throttledFunction();
throttledFunction();
console.log('调用完成');


```



#### **[ ℹ️ 函数拦截 ]**

```csharp
/// <summary>
/// Ext.Function.createInterceptor(origFn, newFn, [scope]) : Function 
/// - origFn: 原始函数
/// - newFn:  拦截函数 ( 返回 false, 原始函数将不执行 )
/// - scope:  函数内部 ( this: 作用域 - 影响原始 + 拦截函数 )
///
/// </summary>

const proxyfn = Ext.Function.createInterceptor(
    function () {
        console.log('函数执行 ...');
    },
    function () {
        return false
    },
);

proxyfn();


```



#### **[ ℹ️ 函数缓存 ]**

```csharp
/// <summary>
/// Ext.Function.memoize ( fn, scope, hashFn ) : Function 
/// - fn: 函数对象
/// - scope:  函数内部 ( this: 作用域 )
/// - hashFn: 缓存键 ( 默认：根据参数 hash )
///
/// </summary>

const proxyfn = Ext.Function.memoize(function (x, y) { 
    console.log(x + y);
});

proxyfn(10, 20); // 计算并输出 30
proxyfn(10, 20); // 直接从缓存中获取结果


```





<!-- tabs:end -->
