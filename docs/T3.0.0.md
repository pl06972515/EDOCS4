<br/>

<!-- tabs:start -->

#### **[ 构造函数 ]**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- [ 在`TS`中：类型属性，有些类似`Python` 的类型属性 ] <span style='color:red'>[ 需显示初始化才能使用，否则认为是类型注解 ]</span>
>
>  <span style='color:red'>[ 在`TS`中：支持成员访问修饰符`private | public ( 默认 ) | protected | readonly | static`]</span>
>
><br/>



```csharp
class TClass { 

     private x?: number;     // [ 可选属性 ] 因未初始化无法访问
     private y: number = 0;  // [ 实例属性 ] 显示初始化
     readonly z: number;     // [ 只读属性 ] [ 需：在构造函数中初始化 ]
    
     public static u: string = "Hello Word";

     # [ 构造函数 ]
     public constructor(x: number, y: number) {
         this.x = x;
         this.y = y;
         this.z = x + y;
     }
    
     # [ TS 中: 函数自动定义到原型对象上 TClass.prototype ]
     public M1(): void {
         console.log(this.z);
     }

     public static M2(): void { 
        
     }

}


```

```csharp
class TClass { 

     public z: number;
    
     # [ 构造函数 ][ 简化：属性定义 ] 
     public constructor(private x: number, private y: number) {
         this.z = x + y;
     }

}


```



```csharp
const o:TClass = new TClass(1, 2);
o.M1();
console.log(o.M1 === TClass.prototype.M1);  // true

TClass.M2();


```



#### **[ ℹ️ 抽象类型 ]**

```csharp
abstract class TBass { 

    protected z: number;
    public constructor(private x: number, public y: number) {
        this.z = x + y;
    }

    public abstract M1(): void;

}

-------------------------------------------
    
class TClass extends TBass {

    public constructor(x: number, y: number) {
        super(x, y);
    }

    override M1(): void {
        console.log(this.y, this.z);
    }
    
}

-------------------------------------------

const o: TBass = new TClass(1, 2);
o.M1();


```



<!-- tabs:end -->







