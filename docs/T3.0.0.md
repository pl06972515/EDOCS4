<br/>

!> <span style='color:red'>[ 在`TS`中，属性声明需初始化 ( 1.提供默认值 | 2.构造函数内赋值 ) ]</span>



<!-- tabs:start -->



#### **[ 构造函数 ]**

```csharp
class TClass { 

     # [ TS 中, 属性访问修饰符 ] private | public | protected | readonly | static
     # [ 忽略隐式 public ]
     private x?: number;
     public y: number = 0;
     readonly z?: number;
    
     public static u: string = "Hello Word";

     # [ 构造函数 ]
     public constructor(x: number, y: number) {
         this.z = x + y
     }
    
     # [ TS 中, 函数访问修饰符 ] private | public | protected | static
     # [ 忽略隐式 public ][ 函数自动定义到原型对象上 TClass.prototype ]
     public M1(): void {
         console.log(this.z);
     }

     public static M2(): void { 
        
     }

}

----------------------------------------------------

class TClass { 

    public z: number;
    # [ 简化：属性定义 ] 
    public constructor(private x: number, private y: number) {
        this.z = x + y;
    }

    public M1(): void {
        console.log(this.z);
    }

}


```

```csharp
const o:TClass = new TClass(1, 2);
o.M1();
console.log(o.M1 === TClass.prototype.M1);  // true

TClass.M2();


```



#### **[ ℹ️ 抽象类型 ]**

```csharp
abstract class TBass { 

    protected z: number;
    public constructor(private x: number, public y: number) {
        this.z = x + y;
    }

    public abstract M1(): void;

}

-------------------------------------------
    
class TClass extends TBass {

    public constructor(x: number, y: number) {
        super(x, y);
    }

    override M1(): void {
        console.log(this.y, this.z);
    }
    
}

-------------------------------------------

const o: TBass = new TClass(1, 2);
o.M1();


```



#### **[ ℹ️ 接口规范 ]**

!> <span style='color:red'>在`TS`中，接口常用于描述对象 [ 对象注解 - 限制对象结构 ]</span>

```csharp
interface IClass {

    x: number; # [ 属性声明 ]
    y: number;

    M1(): void;
    
}

# [ 接口继承 ]
interface IBDrawable extends IADrawable {

    M2(): void;
}

class TClass implements IBDrawable {
    
    x: number;
    y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    M2(): void {
        throw new Error("Method not implemented.");
    }

    M1(): void {
        throw new Error("Method not implemented.");
    } 

}


```



<!-- tabs:end -->







